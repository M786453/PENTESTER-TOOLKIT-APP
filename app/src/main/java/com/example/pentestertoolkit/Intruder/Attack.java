package com.example.pentestertoolkit.Intruder;

import android.util.Log;

import com.example.pentestertoolkit.Global.HttpCommunication;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Attack {

    private static String PAYLOAD_RE = "ยง(.*?)ยง";
    private String request;
    private HttpCommunication.HttpCommunicationCallback httpCommunicationCallback;

    public Attack(String request, HttpCommunication.HttpCommunicationCallback httpCommunicationCallback){
        this.request = request;
        this.httpCommunicationCallback = httpCommunicationCallback;
        // Before starting every attack, recreate the request list of AttackTransactionData
        AttackTransactionsData.requests = new ArrayList<>();
    }

    public void sniper(String[] payloads){

        for (String payload : payloads){

            String modified_request = sniperPayloadPlacer(request, payload);

            HttpCommunication httpCommunication = new HttpCommunication(modified_request, httpCommunicationCallback);

            httpCommunication.sendRequest();

            AttackTransactionsData.requests.add(modified_request);


        }

    }


    public void pitchFork(ArrayList<String[]> payloadSets){

        /**
         * Pitch Fork:
         * A Payload set for each defined payload position
         */



        /**
         * Finding the size of payload set having minimum payloads because no of iteration
         * of payloads placing will be based on that size
         */

        int minSize = payloadSets.get(0).length;

        for (String[] set: payloadSets){
            if (minSize > set.length){
                minSize = set.length;
            }
        }

        /**
         * Payload Placing
         */

        for (int i=0; i < minSize; i++){

            // One Payload from each set which will be used in target request
            ArrayList<String> payloads = new ArrayList<>();

            for (String[] set: payloadSets){
                payloads.add(set[i]);
            }

            // Creating modified request on the basis of list of payloads
            String modified_request = payloadPlacer(payloads);

            HttpCommunication httpCommunication = new HttpCommunication(modified_request, httpCommunicationCallback);

            httpCommunication.sendRequest();

            AttackTransactionsData.requests.add(modified_request);

        }

    }

    public void clusterBomb(ArrayList<String[]> payloadSets){

            ArrayList<ArrayList<String>> payloadsPermutations = new ArrayList<>();

            generatePermutationsHelper(payloadSets, 0, new ArrayList<>(), payloadsPermutations);

            for (ArrayList<String> permutation: payloadsPermutations){

                // Creating modified request on the basis of list of payloads permutation
                String modified_request = payloadPlacer(permutation);

                HttpCommunication httpCommunication = new HttpCommunication(modified_request, httpCommunicationCallback);

                httpCommunication.sendRequest();

                AttackTransactionsData.requests.add(modified_request);

            }


    }




    private String payloadPlacer(ArrayList<String> payloads){

        // Copying original request to new variable
        // so that original request remain unchanged
        StringBuilder modifiedRequest = new StringBuilder(request);

        // Placing payload on their respective positions in request
        for (String pyld: payloads){
            Pattern pattern = Pattern.compile(PAYLOAD_RE);
            Matcher matcher = pattern.matcher(modifiedRequest);
            matcher.find();
            int matchStart = matcher.start();
            int matchEnd = matcher.end();
            modifiedRequest.replace(matchStart,matchEnd,pyld);
        }


        return modifiedRequest.toString();
    }


    private String sniperPayloadPlacer(String request, String payload){

        Pattern pattern = Pattern.compile(PAYLOAD_RE);

        Matcher matcher = pattern.matcher(request);

        return matcher.replaceAll(payload);
    }


    public static int getPayloadPositions(String request){
        try{

            Pattern pattern = Pattern.compile(PAYLOAD_RE);

            Matcher matcher = pattern.matcher(request);


            int matchCount = 0;
            while (matcher.find()) {
                matchCount++;
            }

            return matchCount;
        }catch (Exception e){
            Log.i("ATTACK_ERROR", e.getMessage());

            return 0;
        }
    }


    /**
     * The generatePermutationsHelper method is a recursive helper function that generates permutations by
     * iterating through each element in the current array and recursively calling itself with the next array.
     */
    private static void generatePermutationsHelper(ArrayList<String[]> payload_sets, int index, ArrayList<String> current, ArrayList<ArrayList<String>> payload_permutations) {
        if (index == payload_sets.size()) {
            payload_permutations.add(new ArrayList<>(current));
            return;
        }

        String[] currentPayloadSet = payload_sets.get(index);

        for (String pyld : currentPayloadSet) {
            current.add(pyld);
            generatePermutationsHelper(payload_sets, index + 1, current, payload_permutations);
            current.remove(current.size() - 1);
        }
    }


}
