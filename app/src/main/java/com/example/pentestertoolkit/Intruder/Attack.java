package com.example.pentestertoolkit.Intruder;

import android.net.Uri;
import android.util.Log;
import android.webkit.WebResourceRequest;

import com.example.pentestertoolkit.Global.HttpCommunication;

import java.util.ArrayList;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Attack {

    private static String PAYLOAD_RE = "ยง(.*?)ยง";
    private String request;
    private HttpCommunication.HttpCommunicationCallback httpCommunicationCallback;

    public Attack(String request, HttpCommunication.HttpCommunicationCallback httpCommunicationCallback){
        this.request = request;
        this.httpCommunicationCallback = httpCommunicationCallback;
        // Before starting every attack, recreate the request list of AttackTransactionData
        AttackTransactionsData.requests = new ArrayList<>();
    }

    public void sniper(String[] payloads){

        for (String payload : payloads){

            String modified_request = sniperPayloadPlacer(request, payload);

            HttpCommunication httpCommunication = new HttpCommunication(modified_request, httpCommunicationCallback);

            httpCommunication.sendRequest();

            AttackTransactionsData.requests.add(modified_request);


        }

    }


    public void pitchFork(ArrayList<String[]> payloadSets){

        /**
         * Pitch Fork:
         * A Payload set for each defined payload position
         */



        /**
         * Finding the size of payload set having minimum payloads because no of iteration
         * of payloads placing will be based on that size
         */

        int minSize = payloadSets.get(0).length;

        for (String[] set: payloadSets){
            if (minSize > set.length){
                minSize = set.length;
            }
        }

        /**
         * Payload Placing
         */

        for (int i=0; i < minSize; i++){

            // One Payload from each set which will be used in target request
            ArrayList<String> payloads = new ArrayList<>();

            for (String[] set: payloadSets){
                payloads.add(set[i]);
            }

            // Creating modified request on the basis of list of payloads
            String modified_request = pfPayloadPlacer(payloads);

            HttpCommunication httpCommunication = new HttpCommunication(modified_request, httpCommunicationCallback);

            httpCommunication.sendRequest();

            AttackTransactionsData.requests.add(modified_request);

        }

    }

    private String pfPayloadPlacer(ArrayList<String> payloads){

        // Copying original request to new variable
        // so that original request remain unchanged
        StringBuilder modifiedRequest = new StringBuilder(request);

        // Placing payload on their respective positions in request
        for (String pyld: payloads){
            Pattern pattern = Pattern.compile(PAYLOAD_RE);
            Matcher matcher = pattern.matcher(modifiedRequest);
            matcher.find();
            int matchStart = matcher.start();
            int matchEnd = matcher.end();
            modifiedRequest.replace(matchStart,matchEnd,pyld);
        }


        return modifiedRequest.toString();
    }


    private String sniperPayloadPlacer(String request, String payload){

        Pattern pattern = Pattern.compile(PAYLOAD_RE);

        Matcher matcher = pattern.matcher(request);

        return matcher.replaceAll(payload);
    }


    public static int getPayloadPositions(String request){
        try{

            Pattern pattern = Pattern.compile(PAYLOAD_RE);

            Matcher matcher = pattern.matcher(request);


            int matchCount = 0;
            while (matcher.find()) {
                matchCount++;
            }

            return matchCount;
        }catch (Exception e){
            Log.i("ATTACK_ERROR", e.getMessage());

            return 0;
        }
    }




}
